set nu				"显示行号"
filetype indent on  "自适应不同语言的智能缩进"
set expandtab	"将制表符扩展为空格"
set tabstop=4	"设置编辑时制表符占用空格数"
set shiftwidth=4	"设置格式化时制表符占用空格数"
set softtabstop=4   "让vim把连续数量的空格视为一个制表符"
"set foldmethod=indent   "基于缩进或语法进行代码折叠"
"set foldmethod=syntax
"set foldmethod=marker
set nofoldenable     "启动vim时关闭折叠代码"
set gcr=a:block-blinkon0     "禁止光标闪烁"
set hlsearch			"高亮显示所查关键字符"
set mouse=a			"Enable mouse usage (all modes)"
set showcmd        " Show (partial) command in status line.
set encoding=utf-8
set nrformats=   "默认八进制"
set incsearch    "在执行查找前预览第一处匹配"
set autowrite    "Automatically save before commands like :next and :make
set fdm=marker   "foldmethod"
let mapleader = ","

"add quotation marks"
nnoremap <leader>" viwo<esc>i"<esc>lviw<esc>a"<esc> 

""
"statusline"
""
set statusline=
set statusline+= %7*\[%n]   "buffernr"
set statusline+=%1*\ %<%F\  "file lacation"
set statusline+=%8*\ %=\ row:%l/%L\ (%03p%%)\   "cur line / total line(xx%)"
set laststatus=2    "status line shown as the second line"
set cursorline      "hightlight line"
set cursorcolumn    "hightlight column"
highlight CursorLine cterm=NONE ctermgb=NONE ctermfg=NONE guibg=#073642 guifg=NONE      "line style"
highlight CursorColumn cterm=NONE ctermgb=NONE ctermfg=NONE guibg=#073642 guifg=NONE    "column style"
set guioptions-=m   "cancel the buttom"
set guioptions-=T   "cancel the top"
"cancel scroll bar"
set guioptions-=l
set guioptions-=L
set guioptions-=r
set guioptions-=R

inoremap ( ()<ESC>i
inoremap [ []<ESC>i
inoremap { {<CR>}<ESC>		"花括号自动补全及缩进"
inoremap ' ''<ESC>i
inoremap " ""<ESC>i
nmap <C-\>g :cs find g <C-R>=expand("")<CR> "definition"
nmap <C-\>s :cs find s <C-R>=expand("")<CR> "symbol"
nmap <C-\>t :cs find t <C-R>=expand("")<CR> "string"
nmap <C-\>d :cs find d <C-R>=expand("")<CR> "callee"
nmap <C-\>f :cs find f <C-R>=expand("")<CR> "file"
nmap <C-\>c :cs find c <C-R>=expand("")<CR> "caller"
nmap <space> viw

"command for loading"
command Filter call Load("Filter")
command Servlet call Load("Servlet")
command DBcon call Load("DBcon")
command Jdbc call Load("jdbc_ppt")

"括号自动删除"
function! RemovePairs()
	let l:line = getline(".")
	let l:previous_char = l:line[col(".")-1]
	if index(["(","[","{"],l:previous_char) != -1
		let l:original_pos = getpos(".")
		execute "normal %"
		let l:new_pos = getpos(".")

		if l:original_pos == l:new_pos
			execute "normal! a\<BS>"
			return
		end
		let l:line2 = getline(".")
		if len(l:line2) == col(".")
			execute "normal! v%xa"
		else 
			execute "normal! v%xi"
		end
	else
		execute "normal! a\<BS>"
	end
endfunction
inoremap <BS> <ESC>:call RemovePairs()<CR>a


"忽略多余右括号"
function! RemoveNextDoubleChar(char)
	let l:line = getline(".")
	let l:next_char = l:line[col(".")] "
	if a:char == l:next_char
		execute "normal! l"
	else
		execute "normal! a" . a:char . "" 
	end
endfunction

inoremap ) <ESC>:call RemoveNextDoubleChar(')')<CR>a
inoremap ] <ESC>:call RemoveNextDoubleChar(']')<CR>a
inoremap } <ESC>:call RemoveNextDoubleChar('}')<CR>a

#安装markdown插件
set nocompatible    

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'vundleVim/vundle.vim'

Plugin 'godlygeek/tabular'

Plugin 'plasticboy/vim-markdown'

Plugin 'suan/vim-instant-markdown'

Plugin 'easymotion/vim-easymotion'



#快速开关注释
Plugin 'scrooloose/nerdcommenter'


call vundle#end()
filetype plugin indent on
filetype plugin on


"保存文件自动执行ctags"
"audocmd BufWritePost * call system("ctags -R")

"color"
colorscheme solarized


"templates VIMHOME is as deep as vimrc
autocmd BufNewFile * silent! 0r ./VIMHOME/templates/%:e.tpl


"load model
"param: tplmd directory of templates"
"       tpln  the type of file working on
"       fn    specific file that will be loaded
"return: null
"23:27 23-May-19 by leo
let b:tplmd = "/etc/vim/VIMHOME/templates/"
let b:tpln = "CPP"
function Load(fn) 
    let b:absolutePath = b:tplmd.b:tpln."/".a:fn.".tpl"
    exe "-1r ".b:absolutePath
endfunction


"<c-j> fix the next position"
nnoremap <c-j> /<+.\{-1,}+><cr>c/+>/e<cr>
nnoremap <c-j> <ESC>/<+.\{-1,}+><cr>c/+>/e<cr>
"highlight the placeholder"
match Todo /<+.\++>/

"abbrev"
iabbrev <buffer> fori for (<+init+>; <+condition+>; <+change+>) { 
iabbrev <buffer> /* /**/<ESC>hi

onormap in( :<c-u>normal! f(vi(<cr>
"nnoremap <leader>g :execute "grep! -R" . shellescape(expand("<cword>"))."."<cr>

"========================================================
"prototype of new fold method 
"========================================================
"setlocal foldmethod=expr
"setlocal foldexpr=GetFold(v:lnum)
"
"function! GetFold(lnum)
"    "match the blank line"
"    if getline(a:lnum) =~? '\v^\s*$'    
"        return '-1'
"    endif
"
"    let this_indent = IndentLevel(a:lnum)
"    let next_indent = IndentLevel(NextNonBlankLine(a:lnum))
"
"    if next_indent == this_indent
"        return this_indent
"    elseif next_indent < this_indent
"        return this_indent
"    elseif next_indent > this_indent
"        return '>' . next_indent
"
"    return '0'
"endfunction
"
""calculate indent level"
"function! IndentLevel(lnum)
"    return indent(a:lnum) / &shiftwidth
"endfunction
"
""find the next none blank line"
""-2 will return if error has occured"
"function! NextNonBlankLine(lnum)
"    let numlines = line('$')
"    let current = a:lnum + 1
"
"    while current <= numlines
"        if getline(current) =~? '\v\S'
"            return current
"        endif
"
"        let current += 1
"    endwhile
"
"    return -2
"endfunction
